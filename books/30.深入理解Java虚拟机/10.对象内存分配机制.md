笼统处所：堆上分配

主要具体场所：新生代的 Eden 区

若启动了本地线程分配缓冲：按线程优先在 TLAB 上分配

少数情况：直接老年代

分配规则取决因素：收集器组合、虚拟机参数等

## 堆的结构
划分为两个部分：新生代和老年代，二者默认比例 1 : 2
### 新生代
一般存放新生或临时的对象

划分为 3 个部分，一个 Eden 区和两个 Survivor 区，三者默认比例是 8 : 1 : 1  
这样划分是为了复制算法更好的执行
### 老年代
一般存放存活比较久的对象

## 普遍的内存分配规则

### 优先在 Eden 分配

若 Eden 区没有足够空间，虚拟机将发起一次 Minor GC

GC 一般采用复制算法，将存活对象放入 Survivor 区，若无法放入，只好通过分配担保机制，使存活对象提前转移到老年代

### 大对象直接入老年代

概念：需要大量连续内存空间的 Java 对象，如：很长的字符串或数组

大对象的内存分配对虚拟机来说是个坏消息。更坏的是：遇到一群“朝生夕灭”的“短命”大对象，实际开发中尽量避免（容易导致内存尚多却提前出发垃圾收集，以获取连续内存空间来“安置”大对象）  

##### -XX:PretenureSizeThreshold
效果：大于此参数值的对象直接分配到老年代

单位： B ，不需要带单位

用意：避免复制算法执行时在新生代三个区之间大量的内存复制

注意：此参数只对 Serial 和 ParNew 收集器有效，Parallel 一般不需要设置，若必须要此设定，可以更换 ParNew + CMS 组合

### 长期存活的对象将进入老年代
##### 对象年龄
对象在 Eden 出生后，经过第一次 Minor GC ，仍 存活且可被 Survivor 容纳，将被移动到 Survivor 区，设置年龄为1。此后其在 Survivor 区每“熬过”一次 Minor GC ，年龄增加一岁

默认：对象达到15岁，即可晋升老年代

-XX:MaxTenuringThreshold：对象晋升老年代的年龄阈值

相关概念：对象年龄（Age）计数器

### 对象年龄前提下的灵活晋升
条件： Survivor 区同年龄的对象的大小之和 大于 Survivor 空间的一半

结果：年龄大于等于该年龄的对象，直接进入老年代

### 空间分配担保机制

新生代 Minor GC ，执行前的安全判定（每次执行 Minor GC 前都会进行此检查）：老年代最大可用的连续空间，是否大于新生代（GC 前）所有对象的总空间

##### 判定背景
出于内存利用率的考虑，新生代（采用复制算法）只使用一个 Survivor 空间作为轮换备份。当 Minor GC 后仍存活大量的对象，需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。这就需要老年代有足够的空间容纳这些对象

##### 开关参数：HandlePromotionFailure
含义：允许担保失败

生效版本： JDK 6 Update 24 之前（之后版本不参考此参数，直接对比平均大小）

使用前提：Minor GC 的安全判定失败了

打开时：若老年代最大可用的连续空间，大于历次晋升到老年代的对象的平均大小，则仍然进行 Minor GC
（具有风险，若 Minor GC 失败，则仍要进行 Full GC），否则老年代进行 Full GC

关闭时：老年代进行一次 Full GC

大部分情况会打开此参数，以避免 Full GC 过于频繁