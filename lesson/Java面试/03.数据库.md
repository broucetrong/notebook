## 架构

#### 程序实例
存储管理
缓存机制
SQL解析
日志管理
权限划分
容灾机制
索引管理
锁管理
#### 存储（文件系统）

## 索引
 
### 为什么要使用索引
### 什么样的信息能成为索引
### 索引的数据结构

二叉树 - O(logn) - 容易线性二叉树（O(n)）

#### B-Tree
* 根节点至少包括两个孩子
* 树中每个节点最多含有m个孩子(m>=2)
* 除根节点和叶节点外,其他每个节点至少有eil(m/2)个孩子
* 所有叶子节点都位于同一层

#### B+Tree

相比于B-树，还增加规则：
* 非叶子节点的子树指针与关键字个数相同
* 非叶子节点的子树指针P[i] ,指向关键字值[K[i], K[i+1])的子树
* 非叶子节点仅用来索引,数据都保存在叶子节点中
* 所有叶子节点均有一个链指针指向下一个叶子结点。以便于做范围统计

##### 主流原因
* B+树的磁盘读写代价更低
* B+树的查询效率更加稳定
* B+树更有利于对数据库的扫描

#### Hash索引
#### BitMap索引（位图索引）

### 密集索引和稀疏索引的区别
* 密集索引文件中的每个搜索码值都对应一个索引值
* 稀疏索引文件只为索引码的某些值建立索引项，而且存的是主键值


##### InnoDB数据库引擎
* 若一个主键被定义,该主键则作为密集索引
* 若没有主键被定义,该表的第一个唯一非空索引则作为密集索引
* 若不满足以上条件, innodb内部会生成一个隐藏主键(密集索引)
* 非主键索引存储相关键位和其对应的主键值,包含两次查找

### 衍生出来的问题,以mysal为例
##### * 如何定位并优化慢查询Sql

set global show_query_log = on;
set global long_query_time = 1;

* 根据慢日志定位慢查询SQL
* 使用explain等工具分析sql
* 修改sql或者尽量让sq走索引


##### 联合索引的最左匹配原则的成因
遇到范围查询就停止匹配
in也可以像 = 一样被优化

联合索引的第一个字段是绝对有序，第二个字段是依托于第一个字段的有序来的

##### * 索引是建立得越多越好吗



## 锁模块

##### 常见问题
* MyISAM与InnoDB关于锁方面的区别是什么
* 数据库事务的四大特性
* 事务隔离级别以及各级别下的并发访问问题
* InnoDB可重复读隔离级别下如何避免幻读
* RC, RR级别下的InnoDB的非阻塞读如何实现

### 区别
* MyISAM默认用的是表级锁,不支持行级锁
* InnoDB默认用的是行级锁,也支持表级锁（不走索引的时候）

只有共享锁和共享锁是兼容的

#### MyISAM适合的场景
* 频繁执行全表count语句
* 对数据进行增删改的频率不高,查询非常频繁
* 不使用事务

#### InnoDB适合的场景
* 数据增删改查都相当频繁
* 可靠性要求比较高,要求支持事务

#### 数据库锁的分类
* 按锁的粒度划分,可分为表级锁、行级锁、页级锁
* 按锁级别划分,可分为共享锁、排它锁
* 按加锁方式划分,可分为自动锁、显式锁
* 按操作划分,可分为DML锁、DDL锁
* 按使用方式划分,可分为乐观锁、悲观锁

### 事务的四大特性
* 原子性(Atomic )
* 一致性( Consistency )
* 隔离性( Isolation )
* 持久性( Durability )

### 事务隔离级别以及各级别下的并发访问问题
* 更新丢失一mysql所有事务隔离级别在数据库层面上均可避免
* 脏读--READ-COMMITTED事务隔离级别以上可避免
读到某个数据了，但是这个数据没有提交
* 不可重复读--REPEATABLE-READ事务隔离级别以上可避免
读到某个数据了，但是再次读发现数据变了（被提交过）
REPEATABLE-READ就是在再次读的时候，让窗口看起来数据没变（实际上变了），但是当执行update set value=value-1的时候，就会原形毕露
* 幻读--SRIALIZABLE事务隔离级别可避免
读到了三条，但是更新了四条


### InnoDB可重复读隔离级别下如何避免幻读
表象:快照读(非阻塞读)--伪MVCC
内在: next-key锁(行锁+gap锁)
