## 缓存数据库

### 主流应用架构
1、请求数据存在于缓存
2、直接返回
3、miss
4、穿透查询：穿透缓存数据库
5、回种
6、返回
7、熔断：依赖缓存直接返回
8、直接返回

### Memcache和Redis区别

#### Memcache：代码层次类似Hash
* 支持简单数据类型
* 不支持数据持久化存储
* 不支持主从
* 不支持分片sharding

#### Redis
* 数据类型丰富
* 支持数据磁盘持久化存储
* 支持主从
* 支持分片，Redis3.0支持

#### 为什么Redis能这么快 - 10000+QPS
完全基于内存，绝大部分请求都是纯粹的内存操作，执行效率高
数据结构简单，对数据操作也简单（键值对，HashMap，0(1)）
主线程（处理网络请求）采用单线程（I/O事件的处理、I/O对应的相关请求的处理，还有父子协调、集群协调等，非I/O的处理都是封装成周期性任务）

不会有并发的问题，避免了频繁的上下文切换和锁竞争
采用多路I/O复用
QPS达到峰值时，CPU还没有被跑满，说明CPU并非制约Redis性能的瓶颈（可能是网络等原因）
多核（多个计算单元）CPU，可以启用多个Redis实例
正式运行的Redis Server，肯定不止一个单线程，比如持久化时采用子进行或子线程

使用多路I/O复用模型，非阻塞IO
阻塞IO：用户迟迟不输入所需内容等，发生阻塞，无法对其他客户端提供服务

PS：并行，计算机有多个计算单元，可以同时执行几件事；并发性I/O流，一个计算单元来处理来自多个客户端的流请求

#### 多路I/O复用模型
FD：File Descripto，文件描述符
一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射

##### 传统的阻塞I/O模型
当对某个文件进行读/写，如果发生阻塞，就不会对其他操作做出响应（单线程），导致整个服务不可用

##### 多路I/O复用模型
Select系统调用：监控多个FD的可读/可写情况，线程可以去做别的事情先
Redis采用的I/O多路复用函数（前三个都是O(1)）：epoll（Linux）/kqueue（Mac OS）/evport/select
select（O(n)，其他的都是O(1)）可以在全平台使用，作为一个保底方案
Redis采用react设计模式监听I/O事件

# 数据类型

Redis的单个操作都是原子性的

## String：最基本的数据类型，最大512MB，二进制安全（JPG/序列化对象）

set <key> <value>
get <key>

再次对key进行set，可以覆盖

set count 1
incr count

采用sds结构

## Hash：String元素组成的字典，适合用于存储对象（类似JSON的嵌套方式），大约能存储41个对象/元素？

李磊的对象
hmset lilei name "LiLei" age 26 title "Senior"
hget lilei age
hset lilei title "Pricipal"

## List：字符串列表，按插入顺序排序，大约能存储41个成员

lpush mylist aaa
--从左往右依次取出值，但是是“后进先出”  --> Stack的功能 -->最新消息排行榜
lrange mylist 0 10


## Set：String元素组成的无序集合，通过哈希表实现，不允许重复
添加、删除、查找都是O(1)

sadd myset 111    返回INTEGER
smemebers myset

实例：微博，关注的人、粉丝、共同关注
Redis提供对set集合的求交集并集操作？？？如何操作

## Sorted Set：通过分数（权重参数）来为集合中的成员进行从小到大的排序

--分数小的在前
--分数可以重复，但是value不可以
zadd <key> <score> <value>   

zadd myzset 3 abc
zrangebyscore myzset 0 10

实例：score是学生的成绩，value是学好
实例：任务优先级设定，线程根据优先级执行任务

## HyperLogLog：用于技术
## Geo：用于支持存储地理位置信息

## Redis底层数据类型
1. 简单动态字符串
2. 链表
3. 字典
4. 跳跃表
5. 整数集合
6. 压缩列表
7. 对象

# 从海量Key里查询出某一个固定前缀的Key

## 细节
数据规模（数据边界）

### KEYS pattern：查找所有符合给定模式pattern的key -- 对线上业务影响

keys k1*

一次性返回所有匹配的key
key的数量过大，会使服务卡顿，对内存的消耗和Redis服务器都是一个隐患

### SCAN 从海量Key里查询出某一固定前缀的Key

命令格式：SCAN cursor [MATCH pattern] [COUNT count]
基于游标迭代器，需要基于上一次的游标延续之前的迭代过程
以0作为游标开始一次新的迭代，直到命令返回游标0完成一次完整的遍历(一次遍历中每次cursor值并不一定是递增的)
不保证每次执行都返回某个给定数量（甚至可能是0）的元素，支持模糊查询
一次返回的数量不可控，只能是大概率符合COUNT参数

可能的问题：获取到重复的key --> 使用Set集合过滤一次

scan 0 match k1* count 10

# 如何通过Redis实现分布式锁

## 需要解决的问题
互斥性：只能有一个获取到锁
安全性：只能由持有该锁的客户端删除
死锁：获取锁的客户端宕机等，无法释放锁
容错：部分Redis节点宕机，客户端仍然可以获取和释放锁

## SETNX key value：如果key不存在，则创建并赋值
时间复杂度：O(1)
返回值：成功返回1；失败返回0

setnx locknx test 


## 如何解决SETNX长期有效的问题
EXPIRE key seconds

设置key的生存时间，当key过期时（生存时间为0），会被自动删除

expire locknx 2

分布式锁实现逻辑：
1. SETNX并判断是否有锁
2. 若没有锁，则设置key的有效时间，然后执行代码逻辑
逻辑的风险：原子性得不到满足（SETNX后立马宕机）

## 更优解：SET key value [EX seconds] [PX milliseconds] [NX|XX]
EX second：设置键的过期时间为second秒
PX millisecond：设置键的过期时间为millisecond毫秒
NX：只在键不存在时，才执行SET操作
XX：只在键已经存在时，才执行SET操作
SET操作成功完成时，返回OK，否则返回nil

set locktarget 12345 ex 10 nx 

## 大量的key同时过期的注意事项
集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象 --> 设置key的过期时间时，给每个key的过期时间加上随机值

# 如何使用Redis做异步队列

## 使用List实现队列
RPUSH生产消息，LPOP消费消息

--模拟生产
rpush testlist aaa
--模拟消费
lpop testlist

缺点：没有等待队列里有值就直接消费
弥补：可以通过在应用层引入Sleep机制去调用LPOP重试

## BLPOP key [key ...] timeout：阻塞直到队列有消息或超时
blpop testlist 30

缺点：只能供一个消费者消费

## pub/sub：主题订阅者模式
发送者pub发送消息，订阅者sub接收消息
订阅者可以订阅任意数量的频道topic

subscribe myTopic 
publish myTopic "Hello"

缺点：消息的发布是无状态，无法保证可达（对于发布者来说，消息是即发即失）

# Redis如何做持久化

## RDB（快照）持久化：保存某个时间点的全量数据快照
redis.conf中
规则：save 900 1  在多久之内发生过多少次写入，就进行备份
禁用RDB配置：在save配置的下面，增加配置：save ""

rdb文件是二进制的

命令：
SAVE，阻塞Redis的服务器进程，直到RDB文件被创建完毕
BGSAVE，fork出一个紫禁城来创建RDB文件，不阻塞服务器进程

lastsave：上次执行save操作的时间
 
定期保存某个时间点的rdb文件，作为持久化

### 自动化触发RDB持久化的方式
1. 自动根据redis.conf配置里的SAVE m n定时触发（用的是BGSAVE）
2. 主动复制时，主节点自动触发
3. 指定Debug Reload
4. 执行Shutdown且没有开启AOF持久化

### BGSAVE原理

步骤：
1. 检查子进程是否存在AOF/RDB正在执行
2. 调用rdbSaveBackground，执行fork指令
系统调用fork()：创建进程，Linux下实现了Copy-on-Write

Copy-on-Write：创建父子进程后，不立刻拷贝物理空间，而是仍使用同一个。只有父子进程发生更改时，才会为子进程分配独立的物理空间
如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，知道某个调用者试图修改资源的内容时，系统才会真正复制一份专用的副本给该调用者，而其他调用者所见到的最初的资源仍保持不变（其他调用者看不见这个操作）
多个调用者只在读取操作时可以共享同一份资源，COW在数据处理过程中需要维持一个读请求使用的指针，并在新数据写入完成后，更新这个指针以提高读写并发能力，因此COW也间接提供了数据更新过程中的原子性，在保证数据完整性的同时，还保证了一定的读写效率

### RDB缺点
内存数据的全量同步，如果数据量大并且写操作频繁，会由于I/O而严重影响性能
可能会因为Redis挂掉而丢失上次快照到当前期间的数据

## AOF（Append-Only-File）持久化：保存写状态（默认是关闭的）
记录下除了查询以外的所有变更数据库状态的指令（保存写状态）（纯追加形式）
以append的形式追加保存到AOF文件中（增量）

redis.conf中，appendonly设置成yes，appendfilename “AOF文件名”，appendfsync always/eversec（每隔一秒写入一次）/no（交由操作系统，操作系统一般会等内存满了才会开始执行）

config set appendonly yes
set aofTest "haha"

日志重写解决AOF文件大小不断增大的问题，原理如下：
调用fork()，创建一个子进程
子进程把新的AOF文件（相当于是空白的）写到一个临时文件里，不依赖原来的AOF文件
主进程持续将新的变动同时写到内存和原来的AOF里
主进程获取子进程重写AOF的完成信号，往新AOF同步（子进程活动期间的）增量变动
使用新的AOF文件替换掉旧的AOF文件

bgrewriteaof（类似bgsave）

## Redis数据的恢复
RDB和AOF文件共存情况下的恢复流程

解决方法：直接重启
重启时判定步骤：
1. 是否有AOF文件，有则直接加载AOF
2. 若无AOF，才加载RDB文件

## 优缺点
RDB优点：全量数据快照，文件小，恢复快
RDB缺点：无法保存最近一次快照之后的数据
AOF优点：可读性高，适合保存增量数据，数据不易丢失
AOF缺点：文件体积大，恢复时间长

## RDB-AOF混合持久化方式（Redis 4.0后支持且默认）
混合切入点：AOF重写机制，也是先写一份全量数据，再增加增量。只是此全量数据是以Redis命令方式写入的 --> 采用RDB技术

原理：
AOF重写时，会通过管道从父进程读取增量数据并缓存下来
以RDB格式保存全量数据时，也会从管道读取数据，同时不会造成管道的阻塞
也就是说，AOF的前半段是RDB格式的全量数据，后半段是Redis格式的增量数据

BGSAVE做镜像全量持久化，AOF做增量持久化

## Pipeline及主从同步

### 使用Pipeline的好处
Pipeline和Linux的管道类似
Redis基于请求/相应模型，单个请求处理需要一一应答
Pipeline批量执行指令，节省多次IO往返的时间（允许客户端批量执行命令，命令写入缓存中，再一次性地发送给Redis）
有顺序依赖的指令建议分批发送

### Redis的同步机制（主从同步/从从同步）

主从同步原理

课下：搜索如何配置Redis哨兵、如何配置Redis主从、如何配置Redis集群

一个Master用作写操作，若干个S，用作读操作，他们分别对应一个个独立的Redis Server实例
定期的数据备份也是单独选择一个S节点，这样可以最大程度发挥出Redis的性能

为了保证弱一致性（最终一致性），他们不需要保证同一时刻是一致的，但是一段时间后，是要趋于一致的

全同步过程
Slave发送sync命令到Master
Master启动一个后台进程，将Redis中的数据快照保存到文件中
Master将保存数据快照期间接受到的写命令缓存起来
Master完成写文件操作后，将该文件发送给Slave
Slave使用新的AOF文件替换掉旧的AOF文件
Master将这期间收集的增量写命令发送给Slave端

增量同步过程
Master接受到用户的操作指令，判断是否需要传播到Slave
该操作转化成Redis内部的协议格式，并以字符串的形式存储，将操作记录追加到AOF文件
将操作传播到其他Slave：1、对齐主从库；2、按照Redis的协议格式，往响应缓存写入指令
将缓存中的数据发送给Slave

弊端：不具备高可用性，当Master挂掉之后，Redis将不能对外提供写入操作

### Redis Sentinel（哨兵）

解决主从同步Master宕机后的主动切换问题：
独立运行的进程，接通多个Master - Slave集群，发现Master宕机后，进行自动切换

功能：
监控：检查主从服务器是否运行正常
提醒：通过API向管理员或者其他应用程序发送故障通知
自动故障迁移：主从切换（树立新的Master，别的Slave从它这里同步，客户端向原先的主节点发送请求时，哨兵也会把新的主节点地址发给对方）。

Sentinel是分布式系统，一个架构中可以运行多个，通过流言协议接受主服务器是否下线的信息，并通过投票协议来决定是否执行自动故障迁移，以及选择哪个Slave作为新的主节点（跟ZooKeeper是类似的）

流言协议Gossip - 反熵：在杂乱无章中寻求一致

每个节点都随机地与对方通信，最终所有节点的状态达成一致
种子节点定期随机向其他节点发送节点列表以及需要传播的信息
不保证信息一定会传递给所有节点，但是最终会趋于一致